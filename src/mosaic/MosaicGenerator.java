package mosaic;


import java.awt.Color;
import java.awt.Graphics;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import javax.imageio.ImageIO;

import mosaic.palettegenerator.ColorPaletteGenerator;
import mosaic.palettegenerator.ImageBasedColorPaletteGenerator;

/**
 * OVERVIEW:
 * Generates a series of mosaics with various resolutions (tile sizes) and color palettes. The mosaics are then
 * stitched together into one composite mosaic. See the samples directory for examples.
 * 
 * By default, the colors used in the image will be generated by the ImageBasedColorPaletteGenerator, which uses
 * k-means clustering to select an optimal palette. You will need to include the Java Machine Learning (javaml) JAR
 * that is included with this project. Other palette generators exist, such as the ManualColorPaletteGenerator, 
 * which allows the user to specify the colors to be used. 
 * 
 * USAGE:
 * These public methods may be useful in integrating this library into an application
 * - {@link MosaicGenerator#generateMosaic(BufferedImage, int, List)} - Returns a single mosaic with specified width and colors. Useful if you plan to manipulate the image further.
 * - {@link MosaicGenerator#generateCompositeMosaic(BufferedImage, List, List, ColorPaletteGenerator)} - Returns an image containing all permutations of widths and color ranges.
 * - {@link MosaicGenerator#run(String, String, List, List)} - Generates and saves a composite image. Use this if you don't intend to further manipulate the image.
 * - {@link MosaicGenerator#scaleImage(BufferedImage, int)} - Scales an image back to specified size but will maintain the pixelated mosaic look.
 * 
 * @author alexroussos@gmail.com
 *
 */
public class MosaicGenerator {
	
	private static final String OUTPUT_EXTENSION = "png";

    /**
     * Generate a composite of mosaics based on different color palettes and resolutions.
     * 
     * NOTE: Depending on where images are hosted, they may be unreadable by ImageIO. Images hosted on Dropbox seem to work fine.
     * 
     * @param inputUrl URL of image to be transformed into mosaic.
     * @param outputDirectory Directory where composite image is to be saved. Defaults to "./generated_mosaics"
     * @param colorCounts Number of colors to use in each mosaic (corresponds to rows in composite image) eg {8, 12, 24}
     * @param widths The widths of each mosaic in pixels (corresponds to columns in composite image), eg {50, 100, 200}
     * @throws MalformedURLException
     * @throws IOException
     */
    public void run(String inputUrl, String outputDirectory, List<Integer> colorCounts, List<Integer> widths) throws MalformedURLException, IOException {
        BufferedImage rawImage = ImageIO.read(new URL(inputUrl));
        BufferedImage compositeImage = generateCompositeMosaic(rawImage, colorCounts, widths, new ImageBasedColorPaletteGenerator(rawImage));
        String outputFilename = getOutputFilename(inputUrl);
        File outputFile = new File(outputDirectory, outputFilename);
        outputFile.mkdirs();
        System.out.println("Writing mosaic: " + outputFile.getAbsolutePath());
        ImageIO.write(compositeImage, OUTPUT_EXTENSION, outputFile);
    }
    
    /**
     * Create a large image containing a mosaic for each permutation of number of colors and resolution.
     * The smaller mosaics will be scaled up so that all are the same width as the largest.
     * 
     * @param sourceImage Image from which to generate mosaics
     * @param colorCounts List of how many colors to allow in each variation, eg {8, 16, 32}
     * @param widths Resolution of each variation (height will be scaled to maintain aspect ratio), eg {50, 100, 200}
     * @param paletteGenerator Provides the list of colors to allow in the mosaic
     * @return Composite image
     */
    public BufferedImage generateCompositeMosaic(BufferedImage sourceImage, List<Integer> colorCounts, List<Integer> widths, ColorPaletteGenerator paletteGenerator) {
        int labelOffsetY = 10;
        int cellWidth = Collections.max(widths);
        int cellHeight = cellWidth * sourceImage.getHeight() / sourceImage.getWidth();
        int containerWidth = cellWidth * widths.size();
        int containerHeight = cellHeight * colorCounts.size();
        BufferedImage outImage = new BufferedImage(containerWidth, containerHeight, sourceImage.getType());
        Graphics graphics = outImage.getGraphics();

        int destX1 = 0, destY1 = 0, destX2 = cellWidth, destY2 = cellHeight, srcX1 = 0, srcY1 = 0, srcX2 = 0, srcY2 = 0;

        for (Integer colorCount : colorCounts) {
            destX1 = 0;
            List<Color> colors = paletteGenerator.generateColorPalette(colorCount);
            for (Integer width : widths) {
                BufferedImage tileImage = generateMosaic(sourceImage, width, colors);
                srcX2 = tileImage.getWidth();
                srcY2 = tileImage.getHeight();
                graphics.drawImage(tileImage, destX1, destY1, destX2, destY2, srcX1, srcY1, srcX2, srcY2, null);
                graphics.drawString(srcX2 + "x" + srcY2 + "-" + colorCount + "color", destX1, destY1 + labelOffsetY);
                destX1 = destX2;
                destX2 += cellWidth;
            }
            destY1 = destY2;
            destY2 += cellHeight;
            destX2 = cellWidth;
        }

        return outImage;
    }
    
    /**
     * Generate a single mosaic (one resolution and color set). 
     * If the mosaic is too small, it can be scaled up using {@link MosaicGenerator#scaleImage(BufferedImage, int)}, which will
     * maintain the pixelated mosaic look but result in a larger image that is more suitable for viewing.
     * 
     * @param sourceImage Image from which to generate mosaic
     * @param width How many tiles wide the mosaic will be
     * @param colors Colors to use in the mosaic
     * @return
     */
    public BufferedImage generateMosaic(BufferedImage sourceImage, int width, List<Color> colors) {
    	BufferedImage mosaic = colorImage(scaleImage(sourceImage, width), colors);
    	return mosaic;
    }

    /**
     * Scale an image down to the specified width, maintaining the aspect ratio.
     */
    public BufferedImage scaleImage(BufferedImage image, int targetWidth) {
        double scaleFactor = ((double) targetWidth) / image.getWidth();
        AffineTransform scaleTrans = AffineTransform.getScaleInstance(scaleFactor, scaleFactor);
        AffineTransformOp scaleOp = new AffineTransformOp(scaleTrans, AffineTransformOp.TYPE_BILINEAR);
        int scaledWidth = (int) (image.getWidth() * scaleFactor);
        int scaledHeight = (int) (image.getHeight() * scaleFactor);
        BufferedImage scaledImage = scaleOp.filter(image, new BufferedImage(scaledWidth, scaledHeight, image.getType()));
        return scaledImage;
    }

    /**
     * Generate an image containing only the colors in the specified palette.
     */
    private BufferedImage colorImage(BufferedImage image, List<Color> availableColors) {
        for (int x = 0; x < image.getWidth(); x++) {
            for (int y = 0; y < image.getHeight(); y++) {
                Color c = new Color(image.getRGB(x, y));
                image.setRGB(x, y, getNearestColor(c, availableColors).getRGB());
            }
        }
        return image;
    }

    /**
     * Find the closest color in the palette to the specified target color.
     */
    private Color getNearestColor(Color targetColor, List<Color> availableColors) {
        Color closestColor = null;
        int minDistance = Integer.MAX_VALUE;
        for (Color color : availableColors) {
            int distance = getDistance(targetColor, color);
            if (distance < minDistance) {
                closestColor = color;
                minDistance = distance;
            }
        }
        return closestColor;
    }

    /**
     * Find the Euclidean distance between two colors.
     */
    private int getDistance(Color c1, Color c2) {
        int distance = (int) Math.sqrt((double) Math.pow(c2.getRed() - c1.getRed(), 2) + Math.pow(c2.getGreen() - c1.getGreen(), 2) + Math.pow(c2.getBlue() - c1.getBlue(), 2));
        return distance;
    }
    
    /**
     * Create a filename for a mosaic
     * e.g. mosaic-IMG_1913-20130817-084938.png
     */
    private String getOutputFilename(String inputUrl) {
    	try {
	    	String filename = (new File(inputUrl).getName()); // eg IMG_1913.jpg
	    	String filenameBase = filename.split("\\.")[0]; // eg IMG_1913
	    	String date = new SimpleDateFormat("yyyyMMdd-hhmmss").format(new Date());
	        return "mosaic-" + filenameBase + "-" + date + "." + OUTPUT_EXTENSION;
    	} catch (Exception e) {
    		System.out.println("Error while generating output filename. Resorting to default.");
    		e.printStackTrace();
    		return "mosaic-" + System.currentTimeMillis() + "." + OUTPUT_EXTENSION;
    	}
    }
}