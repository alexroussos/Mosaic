package mosaic;


import java.awt.Color;
import java.awt.Graphics;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import javax.imageio.ImageIO;

import mosaic.palettegenerator.ColorPaletteGenerator;
import mosaic.palettegenerator.ImageBasedColorPaletteGenerator;
import mosaic.palettegenerator.PropertiesFilePaletteGenerator;

/**
 * OVERVIEW:
 * Generates a series of mosaics with various resolutions (tile sizes) and color palettes. The mosaics are then
 * stitched together into one composite mosaic. See the samples directory for examples.
 * 
 * By default, the colors used in the image will be generated by the ImageBasedColorPaletteGenerator, which uses
 * k-means clustering to select an optimal palette. You will need to include the Java Machine Learning (javaml) JAR
 * that is included with this project. Other palette generators exist, such as the ManualColorPaletteGenerator, 
 * which allows the user to specify the colors to be used. 
 * 
 * USAGE:
 * These public methods may be useful in integrating this library into an application
 * - {@link MosaicGenerator#generateMosaic(BufferedImage, int, List)} - Returns a single mosaic with specified width and colors. Useful if you plan to manipulate the image further.
 * - {@link MosaicGenerator#generateCompositeMosaic(BufferedImage, List, List, ColorPaletteGenerator)} - Returns an image containing all permutations of widths and color ranges.
 * - {@link MosaicGenerator#run(String, String, List, List)} - Generates and saves a composite image. Use this if you don't intend to further manipulate the image.
 * - {@link MosaicGenerator#scaleImage(BufferedImage, int)} - Scales an image back to specified size but will maintain the pixelated mosaic look.
 * 
 * @author alexroussos@gmail.com
 *
 */
public class MosaicGenerator {
	
	private static final String OUTPUT_EXTENSION = "png";

    /**
     * Generate a composite of mosaics based on different color palettes and resolutions.
     * 
     * NOTE: Depending on where images are hosted, they may be unreadable by ImageIO. Images hosted on Dropbox seem to work fine.
     * 
     * @param inputUrl URL of image to be transformed into mosaic.
     * @param outputDirectory Directory where composite image is to be saved. Defaults to "./generated_mosaics"
     * @param colorCounts Number of colors to use in each mosaic (corresponds to rows in composite image) eg {8, 12, 24}
     * @param widths The widths of each mosaic in pixels (corresponds to columns in composite image), eg {50, 100, 200}
     * @throws MalformedURLException
     * @throws IOException
     */
    public void run(String inputUrl, String outputDirectory, List<Integer> colorCounts, List<Dimensions> dims) throws MalformedURLException, IOException {
        BufferedImage rawImage = ImageIO.read(new URL(inputUrl));
        String outputFilename = getOutputFilename(inputUrl);
        File outputFile = new File(outputDirectory, outputFilename);
        writeCompositeMosaic(rawImage, colorCounts, dims, new PropertiesFilePaletteGenerator("tinytilemosaics_com_ceramic.properties"), outputFile);
    }

	/**
     * Create a large image containing a mosaic for each permutation of number of colors and resolution.
     * The smaller mosaics will be scaled up so that all are the same width as the largest.
     * 
     * @param sourceImage Image from which to generate mosaics
     * @param colorCounts List of how many colors to allow in each variation, eg {8, 16, 32}
     * @param dims Resolution of each variation (image will be scaled to fit within the given dimensions), eg {50x30, 100x60, 200x120}
     * @param paletteGenerator Provides the list of colors to allow in the mosaic
     * @return Composite image
     */
    public BufferedImage writeCompositeMosaic(BufferedImage sourceImage, List<Integer> colorCounts, List<Dimensions> dims, ColorPaletteGenerator paletteGenerator, File outputFile) {
        int labelOffsetY = 10;
        int cellWidth = getMaxWidth(dims, sourceImage);
        int cellHeight = getMaxHeight(dims, sourceImage);
        int containerWidth = cellWidth * dims.size();
        int containerHeight = cellHeight * colorCounts.size();
        BufferedImage outImage = new BufferedImage(containerWidth, containerHeight, sourceImage.getType());
        Graphics graphics = outImage.getGraphics();

        int destX1 = 0, destY1 = 0, destX2 = cellWidth, destY2 = cellHeight, srcX1 = 0, srcY1 = 0, srcX2 = 0, srcY2 = 0;

        Map<String, Map<String, Integer>> tilesUsed = new LinkedHashMap<String, Map<String,Integer>>();
        for (Integer colorCount : colorCounts) {
            destX1 = 0;
            Map<String, Color> colors = paletteGenerator.generateColorPalette(colorCount);
            for (Dimensions box : dims) {
            	MosaicGenerationResult result = generateMosaic(sourceImage, box, colors);
                BufferedImage tileImage = result.getMosaic();
                srcX2 = tileImage.getWidth();
                srcY2 = tileImage.getHeight();
                graphics.drawImage(tileImage, destX1, destY1, destX2, destY2, srcX1, srcY1, srcX2, srcY2, null);
                String title = srcX2 + "x" + srcY2 + "-" + colorCount + "color";
                graphics.drawString(title, destX1, destY1 + labelOffsetY);
                tilesUsed.put(title, result.getCounts());
                destX1 = destX2;
                destX2 += cellWidth;
            }
            destY1 = destY2;
            destY2 += cellHeight;
            destX2 = cellWidth;
        }
        
        outputFile.mkdirs();
        System.out.println("Writing mosaic: " + outputFile.getAbsolutePath());
        try {
			ImageIO.write(outImage, OUTPUT_EXTENSION, outputFile);
			File metaInfoLocation = new File(outputFile.getParentFile(), outputFile.getName() + ".txt");
			outputMetaInfo(tilesUsed, metaInfoLocation);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

        return outImage;
    }
    
    private int getMaxHeight(List<Dimensions> dims, BufferedImage sourceImage) {
    	int maxHeight = 0;
    	for (Dimensions dimensions : dims) {
			Dimensions scaled = dimensions.scaledToFitWithinThis(sourceImage.getWidth(), sourceImage.getHeight());
			if(scaled.getHeight() > maxHeight){
				maxHeight = scaled.getHeight();
			}
		}
    	
    	return maxHeight;
	}

	private int getMaxWidth(List<Dimensions> dims, BufferedImage sourceImage) {
    	int maxWidth = 0;
    	for (Dimensions dimensions : dims) {
			Dimensions scaled = dimensions.scaledToFitWithinThis(sourceImage.getWidth(), sourceImage.getHeight());
			if(scaled.getWidth() > maxWidth){
				maxWidth = scaled.getWidth();
			}
		}
    	
    	return maxWidth;
	}

	private void outputMetaInfo(Map<String, Map<String, Integer>> tilesUsed, File metaInfoLocation) throws IOException {
    	FileWriter writer = new FileWriter(metaInfoLocation);
    	
        Set<Map.Entry<String, Map<String, Integer>>> dataEntries = tilesUsed.entrySet();
        for (Map.Entry<String, Map<String, Integer>> entry : dataEntries) {
        	writer.write(entry.getKey());
        	writer.write("\n");
            Set<Map.Entry<String, Integer>> colorCounts = entry.getValue().entrySet();
            int total = 0;
            for (Map.Entry<String, Integer> count : colorCounts) {
            	writer.write("\t");
            	writer.write(count.getKey());
            	writer.write(" : ");
            	Integer numberOfTiles = count.getValue();
            	writer.write(numberOfTiles.toString());
            	writer.write("\n");
            	total = total + numberOfTiles.intValue();
            }
            writer.write("total: ");
            writer.write(String.valueOf(total));
            writer.write("\n\n\n");
        }

        writer.flush();
        writer.close();
	}

	/**
     * Generate a single mosaic (one resolution and color set). 
     * If the mosaic is too small, it can be scaled up using {@link MosaicGenerator#scaleImage(BufferedImage, int)}, which will
     * maintain the pixelated mosaic look but result in a larger image that is more suitable for viewing.
     * 
     * @param sourceImage Image from which to generate mosaic
     * @param box How many tiles wide the mosaic will be
     * @param colors Colors to use in the mosaic
     * @return
     */
    public MosaicGenerationResult generateMosaic(BufferedImage sourceImage, Dimensions box, Map<String, Color> colors) {
    	BufferedImage mosaic = scaleImage(sourceImage, box);
    	Map<String, Integer> tileCounts = colorImage(mosaic, colors);
    	return new MosaicGenerationResult(mosaic, tileCounts);
    }

    /**
     * Scale an image down to the specified width, maintaining the aspect ratio.
     */
    public BufferedImage scaleImage(BufferedImage image, Dimensions box) {
    	Dimensions scaledSizes = box.scaledToFitWithinThis(image.getWidth(), image.getHeight());

        double widthScaleFactor = ((double) scaledSizes.getWidth()) / image.getWidth();
        double heightScaleFactor = ((double) scaledSizes.getHeight()) / image.getHeight();
        AffineTransform scaleTrans = AffineTransform.getScaleInstance(widthScaleFactor, heightScaleFactor);
        AffineTransformOp scaleOp = new AffineTransformOp(scaleTrans, AffineTransformOp.TYPE_BILINEAR);
        BufferedImage scaledImage = scaleOp.filter(image, new BufferedImage(scaledSizes.getWidth(), scaledSizes.getHeight(), image.getType()));
        return scaledImage;
    }

    /**
     * Generate an image containing only the colors in the specified palette.
     */
    private Map<String, Integer> colorImage(BufferedImage image, Map<String, Color> availableColors) {
    	Map<String, Integer> tileCounts = new TreeMap<String, Integer>();
        for (int x = 0; x < image.getWidth(); x++) {
            for (int y = 0; y < image.getHeight(); y++) {
                Color c = new Color(image.getRGB(x, y));
                String colorName = getNearestColorName(c, availableColors);
                upColorCount(tileCounts, colorName);
                image.setRGB(x, y, availableColors.get(colorName).getRGB());
            }
        }
        return tileCounts;
    }

    private void upColorCount(Map<String, Integer> tileCounts, String colorName) {
    	Integer count = tileCounts.get(colorName);
    	if(count == null){
    		count = new Integer(0);
    	}
    	tileCounts.put(colorName, new Integer(count.intValue() + 1));
	}

	/**
     * Find the closest color in the palette to the specified target color.
     */
    private String getNearestColorName(Color targetColor, Map<String, Color> availableColors) {
        String closestColorName = "";
        int minDistance = Integer.MAX_VALUE;
        Set<Map.Entry<String, Color>> colorEntries = availableColors.entrySet();
        for (Map.Entry<String, Color> entry : colorEntries) {
            int distance = getDistance(targetColor, entry.getValue());
            if (distance < minDistance) {
                closestColorName = entry.getKey();
                minDistance = distance;
            }
        }
        return closestColorName;
    }

    /**
     * Find the Euclidean distance between two colors.
     */
    private int getDistance(Color c1, Color c2) {
        int distance = (int) Math.sqrt((double) Math.pow(c2.getRed() - c1.getRed(), 2) + Math.pow(c2.getGreen() - c1.getGreen(), 2) + Math.pow(c2.getBlue() - c1.getBlue(), 2));
        return distance;
    }
    
    /**
     * Create a filename for a mosaic
     * e.g. mosaic-IMG_1913-20130817-084938.png
     */
    private String getOutputFilename(String inputUrl) {
    	try {
	    	String filename = (new File(inputUrl).getName()); // eg IMG_1913.jpg
	    	String filenameBase = filename.split("\\.")[0]; // eg IMG_1913
	    	String date = new SimpleDateFormat("yyyyMMdd-hhmmss").format(new Date());
	        return "mosaic-" + filenameBase + "-" + date + "." + OUTPUT_EXTENSION;
    	} catch (Exception e) {
    		System.out.println("Error while generating output filename. Resorting to default.");
    		e.printStackTrace();
    		return "mosaic-" + System.currentTimeMillis() + "." + OUTPUT_EXTENSION;
    	}
    }
}